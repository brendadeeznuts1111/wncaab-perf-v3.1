# v14.2 Implementation Plan: Remote Index Distribution

**Status**: üìã **PLANNED**  
**Target**: Future release  
**Dependency**: v14.1 stable in production

---

## üéØ Feature: Remote Index Distribution via CDN

### Overview

Leverage Bun's automatic `fetch()` decompression of `Content-Encoding: zstd` to enable remote index distribution. This eliminates the need for manual `zstdDecompressSync()` when loading indexes from HTTP/CDN sources.

---

## üîç Technical Details

### Bun's Automatic Decompression

Bun automatically decompresses HTTP responses with `Content-Encoding: zstd`:

```typescript
// Bun automatically handles Content-Encoding: zstd
const response = await fetch("https://cdn.example.com/index.zst", {
  headers: {
    "Accept-Encoding": "zstd"
  }
});

// No manual decompression needed!
const index = await response.text(); // Auto-decompressed
```

**Benefits**:
- ‚úÖ Zero manual decompression code
- ‚úÖ Automatic handling of compression headers
- ‚úÖ Works with any CDN that supports zstd
- ‚úÖ Fallback to uncompressed if zstd not available

---

## üìã Implementation Plan

### Phase 1: URL Detection

Update `loadScanIndex()` to detect HTTP/HTTPS URLs:

```typescript
export async function loadScanIndex(
  indexPath: string = ".scan.index.zst"
): Promise<string[]> {
  // Detect remote URLs
  if (indexPath.startsWith("http://") || indexPath.startsWith("https://")) {
    return await loadRemoteIndex(indexPath);
  }
  
  // Existing local file logic...
}
```

### Phase 2: Remote Index Loader

Create `loadRemoteIndex()` function:

```typescript
/**
 * Load scan index from remote URL (v14.2)
 * Uses Bun's automatic fetch() decompression for Content-Encoding: zstd
 */
async function loadRemoteIndex(url: string): Promise<string[]> {
  await using stack = new DisposableStack();
  
  try {
    // Fetch with zstd encoding support
    const response = await fetch(url, {
      headers: {
        "Accept-Encoding": "zstd"
      }
    });
    
    if (!response.ok) {
      throw new Error(`Failed to fetch index: ${response.status} ${response.statusText}`);
    }
    
    // Bun automatically decompresses Content-Encoding: zstd
    const index = await response.text();
    
    // Parse index content
    const files = index.split("\n").filter(Boolean);
    
    console.log(`üìñ Loaded ${files.length} files from remote index (${url})`);
    
    return files;
  } catch (error) {
    throw new Error(`Failed to load remote index from ${url}: ${error}`);
  }
}
```

### Phase 3: Fallback Logic

Handle cases where zstd is not available:

```typescript
async function loadRemoteIndex(url: string): Promise<string[]> {
  await using stack = new DisposableStack();
  
  try {
    // Try with zstd first
    const response = await fetch(url, {
      headers: {
        "Accept-Encoding": "zstd"
      }
    });
    
    if (!response.ok) {
      throw new Error(`Failed to fetch index: ${response.status}`);
    }
    
    // Check if server supports zstd
    const contentEncoding = response.headers.get("Content-Encoding");
    
    if (contentEncoding === "zstd") {
      // Bun auto-decompresses
      const index = await response.text();
      return index.split("\n").filter(Boolean);
    } else {
      // Fallback: server doesn't support zstd, fetch uncompressed
      console.log("‚ö†Ô∏è  Server doesn't support zstd, fetching uncompressed");
      const uncompressedUrl = url.replace(".zst", "");
      const fallbackResponse = await fetch(uncompressedUrl);
      const index = await fallbackResponse.text();
      return index.split("\n").filter(Boolean);
    }
  } catch (error) {
    throw new Error(`Failed to load remote index: ${error}`);
  }
}
```

---

## üöÄ Usage Examples

### Basic Remote Load

```typescript
// Load from CDN
const files = await loadScanIndex("https://cdn.example.com/.scan.index.zst");
```

### With Fallback

```typescript
// Try remote first, fallback to local
try {
  const files = await loadScanIndex("https://cdn.example.com/.scan.index.zst");
} catch {
  const files = await loadScanIndex(".scan.index.zst"); // Local fallback
}
```

### CDN Distribution Setup

```typescript
// Build and upload to CDN
await buildScanIndex("TODO", ".scan.index.zst");

// Upload to CDN (example with AWS S3)
// aws s3 cp .scan.index.zst s3://cdn.example.com/.scan.index.zst \
//   --content-encoding zstd \
//   --content-type application/octet-stream
```

---

## üìä Performance Benefits

| Metric | Local | Remote (v14.2) | Improvement |
|--------|-------|----------------|-------------|
| **Initial Load** | N/A | CDN latency | Depends on CDN |
| **Subsequent Loads** | File I/O | CDN cache | Faster for distributed teams |
| **Decompression** | Manual | Automatic | Zero code overhead |
| **Bandwidth** | Full size | Compressed | 65% reduction |

---

## üîí Security Considerations

1. **HTTPS Only**: Enforce HTTPS for remote indexes
2. **URL Validation**: Validate URLs before fetching
3. **Content Verification**: Optional checksum verification
4. **Rate Limiting**: Prevent abuse of CDN endpoints

```typescript
function validateRemoteUrl(url: string): void {
  if (!url.startsWith("https://")) {
    throw new Error("Remote indexes must use HTTPS");
  }
  
  // Validate domain whitelist (optional)
  const allowedDomains = ["cdn.example.com", "cdn.internal.com"];
  const urlObj = new URL(url);
  if (!allowedDomains.includes(urlObj.hostname)) {
    throw new Error(`Domain not allowed: ${urlObj.hostname}`);
  }
}
```

---

## üß™ Testing Strategy

### Unit Tests

```typescript
test("loadRemoteIndex with zstd encoding", async () => {
  // Mock fetch response with Content-Encoding: zstd
  const mockResponse = {
    ok: true,
    headers: new Headers({ "Content-Encoding": "zstd" }),
    text: async () => "file1.ts\nfile2.ts\n"
  };
  
  global.fetch = vi.fn().mockResolvedValue(mockResponse);
  
  const files = await loadRemoteIndex("https://cdn.example.com/index.zst");
  
  expect(files).toEqual(["file1.ts", "file2.ts"]);
});
```

### Integration Tests

```typescript
test("loadRemoteIndex fallback to uncompressed", async () => {
  // Test fallback when zstd not available
  // ...
});
```

---

## üìÖ Implementation Timeline

### v14.2.0 (Planned)

- [ ] Add URL detection to `loadScanIndex()`
- [ ] Implement `loadRemoteIndex()` function
- [ ] Add fallback logic for non-zstd servers
- [ ] Add security validation (HTTPS, domain whitelist)
- [ ] Write unit tests
- [ ] Write integration tests
- [ ] Update documentation

### v14.2.1 (Future)

- [ ] Add checksum verification
- [ ] Add caching layer
- [ ] Add retry logic with exponential backoff
- [ ] Add metrics/telemetry

---

## üîó Related Documentation

- `V14.1-FINAL-IMPLEMENTATION.md` - Current implementation
- `V14.1-FINAL-VALIDATION-STAMP.md` - Validation details
- Bun Docs: `fetch()` automatic decompression

---

## ‚úÖ Acceptance Criteria

- [ ] Can load index from HTTPS URL
- [ ] Automatically decompresses zstd content
- [ ] Falls back to uncompressed if zstd not available
- [ ] Validates HTTPS requirement
- [ ] Handles network errors gracefully
- [ ] Maintains backward compatibility with local files
- [ ] All tests passing
- [ ] Documentation updated

---

**Status**: üìã **PLANNED FOR v14.2**

This feature will be implemented after v14.1 is stable in production and validated.

