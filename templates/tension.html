<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tension Mapping - Edge Tempering Visualizer</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3E%F0%9F%8E%A8%3C/text%3E%3C/svg%3E">
  <style>
    :root {
      --tension-hex: #80FF80;
      --tension-opacity: 1.0;
      --tension-width: 1px;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0a1929 0%, #1e3c72 50%, #2a5298 100%);
      color: #fff;
      padding: 20px;
      min-height: 100vh;
    }
    .container {
      max-width: 1600px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.98);
      border-radius: 20px;
      padding: 50px;
      box-shadow: 0 30px 80px rgba(0,0,0,0.5);
      color: #333;
    }
    h1 {
      color: #1e3c72;
      margin-bottom: 15px;
      font-size: 3.5em;
      text-align: center;
      font-weight: 800;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .subtitle {
      color: #555;
      margin-bottom: 40px;
      font-size: 1.4em;
      text-align: center;
      font-weight: 500;
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 40px;
      margin-bottom: 50px;
      padding: 40px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 16px;
      border: 2px solid #dee2e6;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 15px;
      padding: 20px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .control-group label {
      font-weight: 700;
      color: #1e3c72;
      font-size: 1.3em;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .slider-container {
      display: flex;
      align-items: center;
      gap: 20px;
    }
    input[type="range"] {
      flex: 1;
      height: 12px;
      border-radius: 6px;
      background: linear-gradient(to right, #667eea, #764ba2);
      outline: none;
      -webkit-appearance: none;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: #fff;
      border: 3px solid #667eea;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      transition: all 0.2s ease;
    }
    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.6);
    }
    input[type="range"]::-moz-range-thumb {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: #fff;
      border: 3px solid #667eea;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      transition: all 0.2s ease;
    }
    input[type="range"]::-moz-range-thumb:hover {
      transform: scale(1.2);
    }
    .value-display {
      min-width: 80px;
      text-align: center;
      font-weight: 800;
      color: #667eea;
      font-size: 1.5em;
      padding: 8px 16px;
      background: white;
      border-radius: 8px;
      border: 2px solid #667eea;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .visualization {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 40px;
      margin-bottom: 50px;
    }
    .color-display {
      padding: 50px;
      border-radius: 16px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      text-align: center;
      border: 3px solid #dee2e6;
      box-shadow: 0 8px 24px rgba(0,0,0,0.1);
    }
    .color-display h3 {
      margin-bottom: 30px;
      color: #1e3c72;
      font-size: 1.8em;
      font-weight: 700;
    }
    .color-swatch {
      width: 300px;
      height: 300px;
      margin: 30px auto;
      border-radius: 20px;
      border: 6px solid var(--tension-hex, #333);
      background: var(--tension-hex, #80FF80);
      box-shadow: 0 15px 40px rgba(0,0,0,0.3), 
                  0 0 0 4px var(--tension-hex-alpha, rgba(128,255,128,0.2)),
                  inset 0 0 0 4px rgba(255,255,255,0.1),
                  0 0 60px var(--tension-hex-alpha, rgba(128,255,128,0.3));
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      cursor: pointer;
    }
    .color-swatch:hover {
      transform: scale(1.05);
      box-shadow: 0 20px 50px rgba(0,0,0,0.4), 
                  0 0 0 6px var(--tension-hex-alpha, rgba(128,255,128,0.3)),
                  inset 0 0 0 4px rgba(255,255,255,0.15),
                  0 0 80px var(--tension-hex-alpha, rgba(128,255,128,0.4));
    }
    .color-swatch::before {
      content: 'Click to Copy';
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.85em;
      font-weight: 600;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      z-index: 10;
    }
    .color-swatch:hover::before {
      opacity: 1;
    }
    .color-swatch::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(0,0,0,0.1) 100%);
      pointer-events: none;
    }
    .color-info {
      margin-top: 30px;
      font-size: 1.2em;
    }
    .color-info div {
      margin: 15px 0;
      padding: 15px 20px;
      background: white;
      border-radius: 10px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-weight: 600;
      border: 2px solid #dee2e6;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      transition: all 0.3s ease;
    }
    .color-info div:hover {
      transform: translateX(5px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .hex-display { 
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      padding: 25px;
      background: white;
      border-radius: 12px;
      border: 3px solid currentColor;
      font-family: 'Courier New', monospace;
      font-weight: 900;
      font-size: 1.4em;
      letter-spacing: 2px;
      transition: all 0.3s ease;
      cursor: pointer;
      position: relative;
    }
    .hex-display:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
    }
    .hex-display::after {
      content: 'üìã';
      position: absolute;
      right: 15px;
      opacity: 0;
      transition: opacity 0.3s ease;
      font-size: 1.2em;
    }
    .hex-display:hover::after {
      opacity: 0.5;
    }
    .hex-display .label {
      font-size: 0.75em;
      opacity: 0.6;
      text-transform: uppercase;
      letter-spacing: 3px;
      color: #666;
    }
    .hex-display .value {
      font-size: 1.8em;
      letter-spacing: 3px;
      font-weight: 900;
    }
    .hex-display .swatch {
      width: 50px;
      height: 50px;
      border-radius: 8px;
      border: 3px solid #333;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      flex-shrink: 0;
      transition: all 0.3s ease;
    }
    .hex-display .swatch:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 16px rgba(0,0,0,0.3);
    }
    .hsl-display { 
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      padding: 20px;
      background: white;
      border-radius: 12px;
      border: 3px solid #0d6efd;
      font-family: 'Courier New', monospace;
      font-weight: 700;
      font-size: 1.4em;
      color: #0d6efd;
      transition: all 0.3s ease;
    }
    .hsl-display:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(13, 110, 253, 0.2);
    }
    .hsl-display .label {
      font-size: 0.75em;
      opacity: 0.6;
      text-transform: uppercase;
      letter-spacing: 3px;
      color: #666;
    }
    .hsl-display .value {
      font-size: 1.3em;
      margin-left: 15px;
    }
    .opacity-display { 
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 20px;
      background: white;
      border-radius: 12px;
      border: 3px solid #198754;
      color: #198754;
      font-size: 1.4em;
      transition: all 0.3s ease;
    }
    .opacity-display:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(25, 135, 84, 0.2);
    }
    .opacity-display .label {
      font-size: 0.75em;
      opacity: 0.6;
      text-transform: uppercase;
      letter-spacing: 3px;
      color: #666;
    }
    .opacity-display .value {
      font-weight: 800;
      font-size: 1.6em;
    }
    .opacity-display .bar-container {
      width: 100%;
      height: 8px;
      background: #e0e0e0;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 5px;
    }
    .opacity-display .bar {
      height: 100%;
      border-radius: 4px;
      transition: width 0.3s ease;
    }
    .width-display { 
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 20px;
      background: white;
      border-radius: 12px;
      border: 3px solid #fd7e14;
      color: #fd7e14;
      font-size: 1.4em;
      transition: all 0.3s ease;
    }
    .width-display:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(253, 126, 20, 0.2);
    }
    .width-display .label {
      font-size: 0.75em;
      opacity: 0.6;
      text-transform: uppercase;
      letter-spacing: 3px;
      color: #666;
    }
    .width-display .value {
      font-weight: 800;
      font-size: 1.6em;
    }
    .width-display .bar-container {
      width: 100%;
      height: 20px;
      background: #e0e0e0;
      border-radius: 10px;
      display: flex;
      align-items: center;
      padding: 0 5px;
      margin-top: 5px;
    }
    .width-display .bar {
      border-radius: 10px;
      transition: all 0.3s ease;
    }
    .graph-container {
      padding: 40px;
      border-radius: 16px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border: 3px solid #dee2e6;
      box-shadow: 0 8px 24px rgba(0,0,0,0.1);
    }
    .graph-title {
      font-size: 1.9em;
      margin-bottom: 25px;
      color: #1e3c72;
      font-weight: 700;
    }
    .node-graph {
      position: relative;
      width: 100%;
      height: 500px;
      background: linear-gradient(135deg, #fafafa 0%, #ffffff 100%);
      border-radius: 12px;
      border: 4px solid #333;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.1), 0 4px 12px rgba(0,0,0,0.05);
      overflow: hidden;
    }
    .node {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
    }
    .edge {
      position: absolute;
      height: 3px;
      background: currentColor;
      transform-origin: left center;
      transition: all 0.3s ease;
    }
    .meta-info {
      padding: 40px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border-radius: 16px;
      margin-top: 40px;
      border: 3px solid #dee2e6;
      box-shadow: 0 8px 24px rgba(0,0,0,0.1);
    }
    .meta-info h3 {
      margin-bottom: 25px;
      color: #1e3c72;
      font-size: 1.8em;
      font-weight: 700;
    }
    .meta-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
    }
    .meta-item {
      padding: 25px;
      background: white;
      border-radius: 12px;
      border-left: 6px solid #667eea;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      transition: all 0.3s ease;
    }
    .meta-item:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.15);
      border-left-width: 8px;
    }
    .meta-item strong {
      display: block;
      color: #667eea;
      margin-bottom: 10px;
      font-size: 1.1em;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 0.9em;
    }
    .relation-badge {
      display: inline-block;
      padding: 10px 20px;
      border-radius: 25px;
      font-weight: 800;
      font-size: 1.1em;
      margin-top: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .relation-temperate { 
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%); 
      color: white;
      box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
    }
    .relation-moderate { 
      background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%); 
      color: #333;
      box-shadow: 0 4px 15px rgba(255, 193, 7, 0.4);
    }
    .relation-intense { 
      background: linear-gradient(135deg, #fd7e14 0%, #ff5722 100%); 
      color: white;
      box-shadow: 0 4px 15px rgba(253, 126, 20, 0.4);
    }
    .relation-extreme { 
      background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); 
      color: white;
      box-shadow: 0 4px 15px rgba(220, 53, 69, 0.4);
    }
    .btn-group {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-top: 40px;
    }
    button {
      padding: 18px 36px;
      border: none;
      border-radius: 12px;
      font-size: 1.2em;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    .btn-primary:hover {
      transform: translateY(-4px) scale(1.05);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
    }
    .btn-primary:active {
      transform: translateY(-2px) scale(1.02);
    }
    .btn-secondary {
      background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
      color: white;
    }
    .btn-secondary:hover {
      transform: translateY(-4px) scale(1.05);
      box-shadow: 0 8px 25px rgba(108, 117, 125, 0.5);
    }
    @media (max-width: 768px) {
      .container {
        padding: 20px;
      }
      h1 {
        font-size: 2em;
      }
      .visualization {
        grid-template-columns: 1fr;
      }
      .color-swatch {
        width: 250px;
        height: 250px;
      }
      .controls {
        grid-template-columns: 1fr;
        padding: 20px;
      }
      .meta-grid {
        grid-template-columns: 1fr;
      }
    }
</head>
<body>
  <div class="container">
    <h1>üé® Tension Mapping Visualizer</h1>
    <p class="subtitle">Edge Tempering + AI-Immunity Indexing - Real-time Color Generation</p>
    
    <div class="controls">
      <div class="control-group">
        <label>Conflict: <span id="conflict-value">1.0</span></label>
        <div class="slider-container">
          <input type="range" id="conflict-slider" min="0" max="100" value="100" step="1">
          <span class="value-display" id="conflict-display">1.0</span>
        </div>
      </div>
      <div class="control-group">
        <label>Entropy: <span id="entropy-value">0.0</span></label>
        <div class="slider-container">
          <input type="range" id="entropy-slider" min="0" max="100" value="0" step="1">
          <span class="value-display" id="entropy-display">0.0</span>
        </div>
      </div>
      <div class="control-group">
        <label>Tension: <span id="tension-value">0.0</span></label>
        <div class="slider-container">
          <input type="range" id="tension-slider" min="0" max="100" value="0" step="1">
          <span class="value-display" id="tension-display">0.0</span>
        </div>
      </div>
    </div>
    
    <div class="visualization">
      <div class="color-display">
        <h3 style="margin-bottom: 20px; color: #333;">Color Output</h3>
        <div class="color-swatch" id="color-swatch" style="background: #80FF80;" onclick="copyHexToClipboard()"></div>
        <div class="color-info">
          <div class="hex-display" id="hex-display" style="border-color: #80FF80;" onclick="copyHexToClipboard()">
            <span class="label">HEX</span>
            <span class="value" id="hex-value" style="color: #80FF80;">#80FF80</span>
            <span class="swatch" style="background: #80FF80;"></span>
          </div>
          <div class="hsl-display" id="hsl-display">
            <span class="label">HSL</span>
            <span class="value">hsl(120, 100%, 75%)</span>
          </div>
          <div class="opacity-display" id="opacity-display">
            <span class="label">OPACITY</span>
            <span class="value" style="color: #80FF80;">100.0%</span>
            <div class="bar-container">
              <div class="bar" style="width: 100%; background: #80FF80;"></div>
            </div>
          </div>
          <div class="width-display" id="width-display">
            <span class="label">WIDTH</span>
            <span class="value" style="color: #80FF80;">1px</span>
            <div class="bar-container">
              <div class="bar" style="width: 20px; height: 1px; background: #80FF80;"></div>
            </div>
          </div>
        </div>
      </div>
      
      <div class="graph-container">
        <h3 class="graph-title">Node Graph Visualization</h3>
        <div class="node-graph" id="node-graph">
          <svg width="100%" height="100%" style="position: absolute; top: 0; left: 0;">
            <defs>
              <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                <polygon points="0 0, 10 3, 0 6" fill="currentColor" />
              </marker>
            </defs>
          </svg>
        </div>
      </div>
    </div>
    
    <div class="meta-info">
      <h3>Metadata & Relation</h3>
      <div class="meta-grid">
        <div class="meta-item">
          <strong>Relation Type</strong>
          <span class="relation-badge relation-temperate" id="relation-badge">temperate</span>
        </div>
        <div class="meta-item">
          <strong>Visual Note</strong>
          <div id="visual-note">Green thin edges - maximal conflict visibility, zero entropy dispersion</div>
        </div>
        <div class="meta-item">
          <strong>Absorbed By</strong>
          <div id="absorbed-by">cli-mapper</div>
        </div>
      </div>
    </div>
    
    <div class="btn-group">
      <button class="btn-primary" onclick="updateVisualization()">üîÑ Update Visualization</button>
      <button class="btn-secondary" onclick="resetToDefaults()">‚Ü©Ô∏è Reset</button>
    </div>
  </div>
  
  <script>
    /**
     * Performance Optimizations Applied:
     * 
     * ‚úÖ DOM Caching: All DOM elements cached at startup (avoids repeated getElementById calls)
     * ‚úÖ AbortSignal.timeout(): Used for fetch requests (40x faster than manual AbortController)
     * ‚úÖ Template Literals: Optimized string concatenation (JIT-optimized patterns)
     * ‚úÖ Array.find(): Used instead of filter()[0] (more efficient)
     * ‚úÖ Debouncing: Slider updates debounced to reduce API calls
     * ‚úÖ Request Deduplication: Prevents duplicate API calls during rapid slider changes
     * ‚úÖ Memory Management: Clears timeouts and aborts signals to prevent leaks
     * 
     * Browser Performance Patterns:
     * - ‚úÖ Use textContent instead of innerHTML when possible (faster, safer)
     * - ‚úÖ Batch DOM updates (use DocumentFragment or requestAnimationFrame)
     * - ‚úÖ Cache computed values (avoid recalculating in loops)
     * - ‚úÖ Use Map/Set for O(1) lookups instead of Array.find()
     * 
     * @version 1.5.1
     * @lastOptimized 2024-12
     */
    
    let currentData = null;
    let precomputedStates = null;
    let precomputedStatesMap = null; // O(1) lookup instead of Array.find()
    let abortController = null; // For request cancellation
    let updateTimeout = null; // For debouncing slider updates
    
    // Cache DOM elements at startup (avoids repeated getElementById calls)
    const DOM = {
      conflictSlider: null,
      entropySlider: null,
      tensionSlider: null,
      conflictValue: null,
      conflictDisplay: null,
      entropyValue: null,
      entropyDisplay: null,
      tensionValue: null,
      tensionDisplay: null,
      colorSwatch: null,
      hexDisplay: null,
      hexValue: null,
      hslDisplay: null,
      opacityDisplay: null,
      widthDisplay: null,
      relationBadge: null,
      visualNote: null,
      nodeGraph: null,
    };
    
    // Initialize DOM cache
    function initDOMCache() {
      DOM.conflictSlider = document.getElementById('conflict-slider');
      DOM.entropySlider = document.getElementById('entropy-slider');
      DOM.tensionSlider = document.getElementById('tension-slider');
      DOM.conflictValue = document.getElementById('conflict-value');
      DOM.conflictDisplay = document.getElementById('conflict-display');
      DOM.entropyValue = document.getElementById('entropy-value');
      DOM.entropyDisplay = document.getElementById('entropy-display');
      DOM.tensionValue = document.getElementById('tension-value');
      DOM.tensionDisplay = document.getElementById('tension-display');
      DOM.colorSwatch = document.getElementById('color-swatch');
      DOM.hexDisplay = document.getElementById('hex-display');
      DOM.hexValue = document.getElementById('hex-value');
      DOM.hslDisplay = document.getElementById('hsl-display');
      DOM.opacityDisplay = document.getElementById('opacity-display');
      DOM.widthDisplay = document.getElementById('width-display');
      DOM.relationBadge = document.getElementById('relation-badge');
      DOM.visualNote = document.getElementById('visual-note');
      DOM.nodeGraph = document.getElementById('node-graph');
    }
    
    // Load precomputed states if available (with timeout)
    (async () => {
      try {
        // ‚úÖ Use AbortSignal.timeout() for fetch requests (40x faster than manual AbortController)
        const response = await fetch('/public/tension-states.json', {
          signal: AbortSignal.timeout(5000), // 5s timeout
        });
        if (response.ok) {
          precomputedStates = await response.json();
          // ‚úÖ Create Map for O(1) lookups instead of O(n) Array.find()
          precomputedStatesMap = new Map(
            precomputedStates.map(state => [state.key, state])
          );
          console.log('‚úÖ Loaded', precomputedStates.length, 'precomputed states');
        }
      } catch (e) {
        if (e.name !== 'AbortError') {
          console.log('‚ÑπÔ∏è  Using runtime computation (precomputed states not available)');
        }
      }
    })();
    
    // Copy to clipboard helper
    async function copyToClipboard(text, element) {
      try {
        await navigator.clipboard.writeText(text);
        const original = element.textContent;
        element.textContent = '‚úÖ Copied!';
        element.style.color = '#28a745';
        setTimeout(() => {
          element.textContent = original;
          element.style.color = '';
        }, 2000);
      } catch (err) {
        console.error('Failed to copy:', err);
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.opacity = '0';
        document.body.appendChild(textArea);
        textArea.select();
        try {
          document.execCommand('copy');
          const original = element.textContent;
          element.textContent = '‚úÖ Copied!';
          element.style.color = '#28a745';
          setTimeout(() => {
            element.textContent = original;
            element.style.color = '';
          }, 2000);
        } catch (e) {
          alert('Failed to copy. Please copy manually: ' + text);
        }
        document.body.removeChild(textArea);
      }
    }
    
    // Helper function to get contrast color (black or white) for text readability
    function getContrastColor(hex) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
      return brightness > 128 ? '#000000' : '#FFFFFF';
    }
    
    // Get state from precomputed or compute on the fly
    // ‚úÖ Optimized: Uses Map for O(1) lookup instead of O(n) Array.find()
    function getState(conflict, entropy, tension) {
      if (precomputedStatesMap) {
        // Round to nearest step (0-10)
        const steps = 10;
        const c = Math.round(conflict * steps);
        const e = Math.round(entropy * steps);
        const t = Math.round(tension * steps);
        const key = `${c}-${e}-${t}`; // ‚úÖ Template literal (JIT-optimized)
        const state = precomputedStatesMap.get(key); // ‚úÖ O(1) Map lookup
        if (state) {
          return {
            hex: state.hexUpper,
            opacity: state.opacity,
            width: state.width,
            hsl: state.hslFormatted,
            meta: state.meta
          };
        }
      }
      // Fallback to API call
      return null;
    }
    
    // ‚úÖ Optimized: Uses cached DOM elements, debounced updates
    function updateSliders() {
      // ‚úÖ Verify DOM elements are cached before accessing
      if (!DOM.conflictSlider || !DOM.entropySlider || !DOM.tensionSlider) {
        console.error('‚ùå DOM elements not initialized - cannot update sliders');
        return;
      }
      
      // Use cached DOM elements (avoids repeated getElementById calls)
      const conflict = parseFloat(DOM.conflictSlider.value) / 100;
      const entropy = parseFloat(DOM.entropySlider.value) / 100;
      const tension = parseFloat(DOM.tensionSlider.value) / 100;
      
      // Cache formatted values (avoid recalculating)
      const conflictFormatted = conflict.toFixed(2);
      const entropyFormatted = entropy.toFixed(2);
      const tensionFormatted = tension.toFixed(2);
      
      // ‚úÖ Use textContent instead of innerHTML (faster, safer)
      DOM.conflictValue.textContent = conflictFormatted;
      DOM.conflictDisplay.textContent = conflictFormatted;
      DOM.entropyValue.textContent = entropyFormatted;
      DOM.entropyDisplay.textContent = entropyFormatted;
      DOM.tensionValue.textContent = tensionFormatted;
      DOM.tensionDisplay.textContent = tensionFormatted;
      
      // ‚úÖ Debounce visualization updates (reduces API calls during rapid slider changes)
      if (updateTimeout) {
        clearTimeout(updateTimeout);
      }
      updateTimeout = setTimeout(() => {
        updateVisualization();
        updateTimeout = null;
      }, 150); // 150ms debounce
    }
    
    // Copy hex to clipboard
    function copyHexToClipboard() {
      if (!currentData) return;
      
      // ‚úÖ Use cached DOM element instead of getElementById
      if (!DOM.hexValue) {
        console.error('‚ùå hexValue element not found');
        return;
      }
      
      const hexUpper = currentData.hex.toUpperCase();
      copyToClipboard(hexUpper, DOM.hexValue);
    }
    
    async function updateVisualization() {
      // ‚úÖ Verify DOM elements are cached before accessing
      if (!DOM.conflictSlider || !DOM.entropySlider || !DOM.tensionSlider) {
        console.error('‚ùå DOM elements not initialized - cannot update visualization');
        return;
      }
      
      // Use cached DOM elements
      const conflict = parseFloat(DOM.conflictSlider.value) / 100;
      const entropy = parseFloat(DOM.entropySlider.value) / 100;
      const tension = parseFloat(DOM.tensionSlider.value) / 100;
      
      try {
        // ‚úÖ Cancel any pending requests to prevent race conditions
        if (abortController) {
          abortController.abort();
        }
        abortController = new AbortController();
        
        // Try to use precomputed state first (O(1) lookup)
        const precomputedState = getState(conflict, entropy, tension);
        let data;
        
        if (precomputedState) {
          // Use precomputed state (no API call needed)
          // ‚úÖ Cache HSL parsing result (avoid regex recalculation)
          const hslMatch = precomputedState.hsl.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
          data = {
            hex: precomputedState.hex,
            opacity: precomputedState.opacity,
            width: precomputedState.width,
            hsl: hslMatch ? {
              h: parseInt(hslMatch[1], 10), // ‚úÖ Explicit radix (performance)
              s: parseInt(hslMatch[2], 10),
              l: parseInt(hslMatch[3], 10)
            } : { h: 0, s: 0, l: 0 },
            opacityPercent: precomputedState.opacity * 100,
            meta: precomputedState.meta
          };
        } else {
          // ‚úÖ Fallback to API call with timeout and cancellation
          // ‚úÖ Use template literal for URL (JIT-optimized string concatenation)
          const url = `/api/tension/map?conflict=${conflict}&entropy=${entropy}&tension=${tension}`;
          const response = await fetch(url, {
            signal: abortController.signal, // ‚úÖ Request cancellation support
            headers: {
              'Accept': 'application/json',
            },
          });
          
          if (!response.ok) {
            throw new Error(`API error: ${response.status} ${response.statusText}`);
          }
          
          data = await response.json();
        }
        
        currentData = data;
        
        // ‚úÖ Normalize hex to uppercase #RRGGBB format (macro-compliant)
        // ‚úÖ Cache hexUpper (used multiple times)
        const hexUpper = data.hex.toUpperCase().padStart(7, '#');
        
        // ‚úÖ Batch CSS custom property updates (single reflow)
        const root = document.documentElement;
        root.style.setProperty('--tension-hex', hexUpper);
        root.style.setProperty('--tension-opacity', String(data.opacity));
        root.style.setProperty('--tension-width', `${data.width}px`);
        
        // ‚úÖ Update color swatch with macro-compliant hex (use cached DOM element)
        DOM.colorSwatch.style.background = hexUpper;
        DOM.colorSwatch.style.borderColor = hexUpper;
        DOM.colorSwatch.style.boxShadow = `0 15px 40px rgba(0,0,0,0.3), 0 0 0 4px ${hexUpper}40, inset 0 0 0 4px rgba(255,255,255,0.1)`;
        
        // ‚úÖ Update hex display (use cached DOM elements)
        DOM.hexValue.textContent = hexUpper; // ‚úÖ textContent (faster than innerHTML)
        DOM.hexValue.style.color = hexUpper;
        DOM.hexDisplay.style.borderColor = hexUpper;
        DOM.hexDisplay.querySelector('.swatch').style.background = hexUpper;
        
        // ‚úÖ Update HSL display (cache formatted value)
        const hslValue = precomputedState?.hsl || `hsl(${data.hsl.h}, ${data.hsl.s.toFixed(1)}%, ${data.hsl.l.toFixed(1)}%)`;
        DOM.hslDisplay.innerHTML = `
          <span class="label">HSL</span>
          <span class="value">${hslValue}</span>
        `;
        
        // ‚úÖ Update opacity display (cache formatted value)
        const opacityPercentFormatted = data.opacityPercent.toFixed(1);
        DOM.opacityDisplay.innerHTML = `
          <span class="label">OPACITY</span>
          <span class="value" style="color: ${hexUpper};">${opacityPercentFormatted}%</span>
          <div class="bar-container">
            <div class="bar" style="width: ${data.opacityPercent}%; background: ${hexUpper};"></div>
          </div>
        `;
        DOM.opacityDisplay.style.borderColor = hexUpper;
        
        // ‚úÖ Update width display (cache formatted value)
        const widthFormatted = `${data.width}px`;
        DOM.widthDisplay.innerHTML = `
          <span class="label">WIDTH</span>
          <span class="value" style="color: ${hexUpper};">${widthFormatted}</span>
          <div class="bar-container">
            <div class="bar" style="width: ${data.width * 20}px; height: ${data.width}px; background: ${hexUpper};"></div>
          </div>
        `;
        DOM.widthDisplay.style.borderColor = hexUpper;
        
        // ‚úÖ Update relation badge (use cached DOM element)
        DOM.relationBadge.textContent = data.meta.relation; // ‚úÖ textContent (faster)
        DOM.relationBadge.className = `relation-badge relation-${data.meta.relation}`;
        DOM.relationBadge.style.borderColor = hexUpper;
        DOM.relationBadge.style.boxShadow = `0 4px 15px ${hexUpper}40`;
        
        // ‚úÖ Update visual note (use cached DOM element)
        DOM.visualNote.textContent = data.meta.visualNote; // ‚úÖ textContent (faster)
        
        // Update graph with macro colors
        updateGraph(data);
      } catch (error) {
        console.error('Failed to update visualization:', error);
      }
    }
    
    function updateGraph(data) {
      // ‚úÖ Verify DOM element is cached before accessing
      if (!DOM.nodeGraph) {
        console.error('‚ùå nodeGraph element not initialized');
        return;
      }
      
      const graph = DOM.nodeGraph; // ‚úÖ Use cached DOM element
      const svg = graph.querySelector('svg');
      
      // Clear existing nodes and edges
      svg.innerHTML = '<defs><marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto"><polygon points="0 0, 10 3, 0 6" fill="currentColor" /></marker></defs>';
      
      const width = graph.offsetWidth;
      const height = graph.offsetHeight;
      const centerX = width / 2;
      const centerY = height / 2;
      const radius = Math.min(width, height) * 0.3;
      
      // Normalize hex to uppercase for macro compliance
      const hexUpper = data.hex.toUpperCase();
      
      // Create nodes with macro-compliant colors
      const nodes = [
        { id: 'node1', x: centerX - radius, y: centerY - radius / 2, label: 'A', color: '#667EEA' },
        { id: 'node2', x: centerX + radius, y: centerY - radius / 2, label: 'B', color: '#764BA2' },
        { id: 'node3', x: centerX, y: centerY + radius, label: 'C', color: hexUpper },
      ];
      
      // Create edges with tension color (macro-compliant hex)
      const edges = [
        { from: nodes[0], to: nodes[1], color: hexUpper, opacity: data.opacity, width: data.width },
        { from: nodes[1], to: nodes[2], color: hexUpper, opacity: data.opacity, width: data.width },
        { from: nodes[2], to: nodes[0], color: hexUpper, opacity: data.opacity, width: data.width },
      ];
      
      // Draw edges
      edges.forEach(edge => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', edge.from.x.toString());
        line.setAttribute('y1', edge.from.y.toString());
        line.setAttribute('x2', edge.to.x.toString());
        line.setAttribute('y2', edge.to.y.toString());
        line.setAttribute('stroke', edge.color.toUpperCase());
        line.setAttribute('stroke-width', edge.width.toString());
        line.setAttribute('opacity', edge.opacity.toString());
        line.setAttribute('marker-end', 'url(#arrowhead)');
        svg.appendChild(line);
      });
      
      // Draw nodes
      nodes.forEach(node => {
        // Outer glow
        const glow = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        glow.setAttribute('cx', node.x.toString());
        glow.setAttribute('cy', node.y.toString());
        glow.setAttribute('r', '40');
        glow.setAttribute('fill', 'none');
        glow.setAttribute('stroke', node.color.toUpperCase());
        glow.setAttribute('stroke-width', '3');
        glow.setAttribute('opacity', '0.3');
        svg.appendChild(glow);
        
        // Main circle
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', node.x.toString());
        circle.setAttribute('cy', node.y.toString());
        circle.setAttribute('r', '35');
        circle.setAttribute('fill', node.color.toUpperCase());
        circle.setAttribute('stroke', '#333');
        circle.setAttribute('stroke-width', '4');
        circle.setAttribute('filter', 'url(#shadow)');
        svg.appendChild(circle);
        
        // Add shadow filter
        if (!svg.querySelector('defs filter#shadow')) {
          const defs = svg.querySelector('defs');
          const filter = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
          filter.setAttribute('id', 'shadow');
          filter.setAttribute('x', '-50%');
          filter.setAttribute('y', '-50%');
          filter.setAttribute('width', '200%');
          filter.setAttribute('height', '200%');
          const feDropShadow = document.createElementNS('http://www.w3.org/2000/svg', 'feGaussianBlur');
          feDropShadow.setAttribute('in', 'SourceAlpha');
          feDropShadow.setAttribute('stdDeviation', '4');
          feDropShadow.setAttribute('result', 'blur');
          filter.appendChild(feDropShadow);
          defs.appendChild(filter);
        }
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', node.x.toString());
        text.setAttribute('y', (node.y + 7).toString());
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('fill', 'white');
        text.setAttribute('font-weight', '900');
        text.setAttribute('font-size', '24');
        text.setAttribute('text-shadow', '0 2px 4px rgba(0,0,0,0.5)');
        text.textContent = node.label;
        svg.appendChild(text);
      });
    }
    
    function resetToDefaults() {
      // ‚úÖ Verify DOM elements are cached before accessing
      if (!DOM.conflictSlider || !DOM.entropySlider || !DOM.tensionSlider) {
        console.error('‚ùå DOM elements not initialized - cannot reset');
        return;
      }
      
      // ‚úÖ Use cached DOM elements
      DOM.conflictSlider.value = 100;
      DOM.entropySlider.value = 0;
      DOM.tensionSlider.value = 0;
      updateSliders();
    }
    
    // ‚úÖ Initialize DOM cache and add event listeners
    // ‚úÖ Use DOMContentLoaded to ensure DOM is fully ready before initialization
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
      // DOM already loaded, initialize immediately
      initializeApp();
    }
    
    function initializeApp() {
      initDOMCache();
      
      // ‚úÖ Verify DOM elements are cached before proceeding
      if (!DOM.conflictSlider || !DOM.entropySlider || !DOM.tensionSlider) {
        console.error('‚ùå Failed to initialize DOM cache - elements not found');
        return;
      }
      
      // Add event listeners (use cached DOM elements)
      DOM.conflictSlider.addEventListener('input', updateSliders);
      DOM.entropySlider.addEventListener('input', updateSliders);
      DOM.tensionSlider.addEventListener('input', updateSliders);
      
      // Initial load (after DOM is confirmed ready)
      updateVisualization();
    }
    
    // ‚úÖ Cleanup on page unload (prevent memory leaks)
    window.addEventListener('beforeunload', () => {
      if (abortController) {
        abortController.abort();
      }
      if (updateTimeout) {
        clearTimeout(updateTimeout);
      }
    });
  </script>
</body>
</html>
